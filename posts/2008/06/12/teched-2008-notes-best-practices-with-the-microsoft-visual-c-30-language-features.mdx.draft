---
title: "TechEd 2008 notes: Best Practices with the Microsoft Visual C# 3.0 Language Features  #.NET  #teched2008"
sort: 2553
---
Still catching up on posting my notes from TechEd last week. I probably would've gotten this up last night if I hadn't been in the basement most of the evening for tornado warnings.

Best Practices with the Microsoft Visual C# 3.0 Language Features
Mads Torgersen
Program Manager for the C# Language
Microsoft

He's the guy who figures out what features go in the next version of the language, to keep us on our toes.

Goals of this talk
<ul>
  <li>Show new features</li>
  <li>Important do's and don'ts</li>
  <li>Introduce LINQ</li>
</ul>

Despite the name of the talk, more time will be given to C# 3 features than to best practices. Best practices are in there, but they're not the star of the show. If you're going to be annoyed by that, start being annoyed now, rather than waiting until the end.

C# 3 in a Nutshell
<ul>
  <li>Imperative =&gt; Declarative</li>
  <ul>
    <li>Before: modify state in little bits</li>
    <li>Leads to a lot of detail in describing how you want things done</li>
    <li>New: say what you want, rather than how you want it done</li>
    <li>MS has freedom to give us performance and flexibility</li>
  </ul>



  <li>How =&gt; What</li>
  <li>Make queries first-class</li>
</ul>

(Incomplete) list of new features
<ul>
  <li>Auto properties</li>
  <li>Implicitly typed locals</li>
  <li>Object and collection initializers</li>
  <li>Extension methods</li>
  <li>Lambda</li>
  <li>Queries</li>
  <li>Anonymous types</li>
  <li>Expression types</li>
  <li>...a couple not shown in this talk</li>
</ul>

<h3>Automatically Implemented Properties</h3>
<ul>
  <li>Just sucking up to programmers' laziness; nothing deep</li>
</ul>
<pre>class Customer
{
    public string CustomerID { get; set; }
    public string ContactName { get; set; }
}</pre>
<ul>
  <li>Simplify common scenario</li>
  <li>You can see that they're trivial</li>
  <li>Limitations</li>
  <ul>
    <li>No body -&gt; no breakpoints</li>
    <li>No field -&gt; no default value</li>
  </ul>
  <li>There can be serialization issues if you change an automatic property to a real property, since the autogenerated field has a magic name that's stored in your serialized data</li>
</ul>

Lure of Brevity: Best practices for auto properties
<ul>
  <li>Only use this for things that really are simple get/set properties</li>
  <li>Hold on to your...</li>
  <ul>
    <li>Get-only and set-only properties</li>
    <li>Validation logic</li>
  </ul>
  <li>Private accessors (<code>get; private set;</code>) are usually not the answer -- too easy to forget you didn't intend for them to be set capriciously, and add code a year from now that sets them in an unsafe way</li>
  <li>Be careful what you make settable:</li>
</ul>

<pre>// Bad
class Customer {
    public string CustomerKey { get; set; }
    // Key really shouldn't be settable</pre>

<h3>Implicitly Typed Locals</h3>
<ul>
  <li><code>var</code> keyword, type inference</li>
  <li>I won't bother quoting his code snippet, you've seen it before</li>
  <li>Intellisense can show you the actual type -- hover over the <code>var</code></li>
  <li>Remove redundancy, repetition, clutter</li>
  <li>Allow focus on code flow</li>
  <li>Great for experimentation: you can change something's return type and there's a much better chance that everything will still compile (Roy would probably say there's <a href="http://blog.excastle.com/2008/06/03/teched-2008-notes-design-patterns-in-dynamic-languages/">more essence and less ceremony</a>)</li>
  <li>"Surprisingly liberating experience"</li>
</ul>

Redundancy is not always bad: best practices for <code>var</code>
<ul>
  <li><strong>Explicit types</strong> on locals (i.e., <em>not</em> using var) will...</li>
  <ul>
    <li>Improve readability of complex code, esp. if method name doesn't make its return type clear</li>
    <li>Allow typechecking on right-hand side (when you want that)</li>
    <li>Can be more general than the right-hand side</li>
  </ul>
  <li>Think: Who is the reader?</li>
  <li>Find your own compromise between the two extremes</li>
</ul>

Side note: <code>ObjectDumper</code> class from samples (kind of like <code>.inspect</code> in Ruby)

<h3>Object and collection initializers</h3>
<ul>
  <li>Traditionally very imperative. Start with empty collection, then create an empty Customer, then initialize it, then add it.</li>
  <li>Lots of intermediate results lying around.</li>
</ul>
<pre>static IEnumerable&lt;Customer&gt; GetCustomers()
{
    var custs = new List&lt;Customer&gt;()
    {
        new Customer {
            CustomerID = "MADST",
            ContactName = "Mads Torgersen",
            City = "Redmond"
        }
    };
}</pre>
<ul>
  <li>Can omit empty parens after <code>new</code> if you use an object initializer</li>
  <li>Code-result isomorphism</li>
  <ul>
    <li>Structure of code parallels structure of object you want.</li>
  </ul>
  <li>Expression-oriented</li>
  <ul>
    <li>Can be used in expression context</li>
  </ul>
  <li>Atomic</li>
  <ul>
    <li>No intermediate results</li>
    <li>Create object and collection in one fell swoop. Don't need temporary variables. Don't expose any intermediate states at all.</li>
  </ul>
  <li>Compositional</li>
  <li>May not need as many constructor overloads</li>
</ul>

Constructors are still good: best practices for object and collection initializers
<ul>
  <li>Constructors...</li>
  <ul>
    <li>Show intent</li>
    <li>Enforce initialization</li>
    <li>Initialize get-only data</li>
  </ul>
  <li>Initializers and constructors compose well</li>
</ul>
<pre>var c = new Customer("MADST"){
    ContactName = ...</pre>

<h3>Extension Methods</h3>
<ul>
  <li>You've seen these demos too (well, maybe not <code>GetLondoners()</code> specifically)</li>
  <li>Dilemma with very general types: you use them in a specific setting, and sometimes you want a special view on it and wish you could add a couple more methods to the original declaration, just for your use in that setting</li>
  <li>One really interesting benefit: can add methods to a generic of only certain types, e.g. can have a method on IEnumerable&lt;Customer&gt; that isn't there on the general IEnumreable&lt;int&gt;. I like this!</li>
  <li>Declared like static methods, can call like instance methods</li>
  <li>New functionality on existing types</li>
  <li>Scoped by using clauses</li>
  <li>Interfaces and constructed types</li>
</ul>

Cluttering your Namespace: best practices for extension methods
<ul>
  <li>Consider making them optional (separate namespace), so people can use your library without necessarily needing your extension methods (extension methods for working with types from <code>MyNamespace.Foo</code> should be in their own namespace, not right in <code>MyNamespace.Foo</code>)</li>
  <li>Don't put them on all objects!</li>
  <li>Make them behave like instance methods.</li>
</ul>
<pre>namespace System
{
    public static class MyExtensions
    {
        // Don't do this
        public static bool IsNull(this object o) {
            return o == null;
        }
    }
}</pre>
<ul>
  <li>That's a worst practice. It violates all three of the above guidelines. Don't do it just because it's cool.</li>
</ul>

<h3>Lambda Expressions</h3>
<ul>
  <li>Predicate&lt;T&gt; -- function that takes T and returns bool</li>
  <li><code>=&gt;</code>: Some call this the "fat arrow"</li>
  <li>Terse anonymous functions</li>
  <li>Parameter types inferred from context</li>
  <li>Closures: capture local state (also true of anonymous methods)</li>
</ul>

Condensed Power: best practices for lambda expressions
<ul>
  <li>Keep them small</li>
  <ul>
    <li>That's the point of making them terse</li>
    <li>Yank them out if they get too big</li>
  </ul>
  <li>Watch that capture (of local variables, and using them inside the lambda)</li>
  <ul>
    <li>Can have unexpected results</li>
    <li>Exposing private state</li>
  </ul>
  <li>Watch the complexity</li>
  <ul>
    <li>Functions of functions returning functions...</li>
  </ul>
  <li>Think: Who executes this lambda, and when?</li>
</ul>

<h3>Queries</h3>
<ul>
  <li>Functional: doesn't mutate the original collection; instead returns a new collection</li>
  <li><code>using System.Linq;</code> == "Linq to Objects"</li>
  <li>Extension methods give you pipelining: <code>customers.Where(...).Select(...)</code></li>
  <li>Language integrated -- use anywhere! (if you're using C#)</li>
  <li>Query expressions for common uses</li>
  <li>Mix and match query and method syntax</li>
  <li>Expect deferred execution (can do <code>ToArray</code>)</li>
</ul>

Beware monadic complexity hell: best practices for queries
<ul>
  <li>Another powerful complexifier</li>
  <li>Do you need to roll your own query provider?</li>
  <li>Use query pattern for queries only!</li>
  <ul>
    <li>Avoid abusing query syntax for other magic</li>
    <li>Even if you know about monads! (Your users don't)</li>
  </ul>
</ul>

<h3>Anonymous types</h3>
<ul>
  <li><code>select new { Name = c.ContactName, c.City }</code> -- smart enough to call the second property <code>City</code></li>
  <li>Temporary local results</li>
  <li>Shallow immutability and value equality</li>
  <li>Does a nice job on the generated classes</li>
  <ul>
    <li>Value-based equality</li>
    <li>Good hashcodes</li>
  </ul>
</ul>

Keep it local: best practices for anonymous types
<ul>
  <li>If you need a type, make one! Don't use an anonymous type and work around problems. Only use where they don't limit you.</li>
</ul>

<h3>Expression trees</h3>
<ul>
  <li>Runtime object model of code</li>
  <li>Created from lambda expressions</li>
  <li>Language independent. LINQ to SQL doesn't know about C#; it just knows about expression trees.</li>
  <li>Compile back into delegates on demand. <code>.Compile()</code> method -- even if you created it with factories instead of a lambda.</li>
</ul>

The Lure of Doing Magic: best practices for expression trees
<ul>
  <li>You can interpret expression trees any way you like.</li>
  <li>Don't!</li>
  <ul>
    <li>Stay close to expected semantics</li>
    <li>Avoid special magic names, etc.</li>
  </ul>
</ul>

Final words
<ul>
  <li>C# 3 and LINQ can change the way you code...</li>
  <ul>
    <li>Declaratively: more of the what, less of the how</li>
    <li>Eloquently</li>
    <li>And with lots of queries. Don't think of queries as something heavyweight for external data.</li>
  </ul>
  <li>...but they don't have to!</li>
</ul>
