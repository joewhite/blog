---
title: "Agile and Extreme Programming: A Pragmatic Approach (part 1)  #.NET  #Delphi  #borcon2005  #extreme programming"
sort: 2214
---
The first of the preconference tutorials I'm going to this year. Presented by <a href="http://www.nealford.com/">Neal Ford</a>, Application Architect, <a href="http://www.thoughtworks.com/index.html">ThoughtWorks</a>.

We're at the first break, so here's a brain-dump of all the notes I've taken so far. I haven't had a chance to simplify these yet (grin). This part is mostly a background of where agile came from, and some of the principles behind it, so if you're already on XP you can probably skim this one.
<p>Overview:</p>

<ul style="margin-top: 0in" type="disc">
<li>Agile in general, XP in particular</li>
<li>ThoughtWorks uses XP on a daily basis</li>
<li>What makes XP a discipline, not just a random set of activities</li>
<li>How to gently introduce agile in general, and XP in particular, into your organization</li>
<li>It's called "Agile" for a reason. Be suspicious of anything that claims to be the "<st1:street><st1:address>One True Way</st1:address></st1:street>". It won't happen. You will have to adapt the process.</li>
</ul>
<p>&nbsp;</p>

<ul style="margin-top: 0in" type="disc">
<li>Waterfall, or BDUF (Big Design Up Front), works well for engineering physical objects</li>
<li>Assumes that requirements don't change
<ul style="margin-top: 0in" type="circle">
<li>Does anyone (besides NASA) have software requirements like this?</li>
<li>Not today, in the age of Internet time!</li>
<li>By the time you create software this way, the need for it will have disappeared</li>
</ul>
</li>
<li>"Let me write the whole thing, and then I'll tell you exactly how long it's going to take"</li>
<li>Requirements change a lot, and those changes have to be implemented quickly</li>
<li>"Waterfall" has gotten negative connotations; euphemisms have sprung up, like SDLC (Software Development Life Cycle)</li>
</ul>
<p>Cost of change?</p>

<ul style="margin-top: 0in" type="disc">
<li>The later in the dev cycle that a requirement changes, the bigger the impact</li>
<li>50-200 times as costly to change late in the cycle as it is early in the cycle &ndash; ripple effects</li>
<li>How can you make coding changes with confidence?
<ul style="margin-top: 0in" type="circle">
<li>Agile makes this rule not true anymore &ndash; cost becomes mostly linear</li>
<li>This idea came from mid-70s &ndash; not true anymore (except with waterfall)</li>
<li>In a waterfall shop, try asking "We're still doing development the same way we did in the mid-70s &ndash; why don't we try doing accounting with mechanical calculators and ledger sheets? It was good enough then!"</li>
</ul>
</li>
</ul>
<p><o:p> </o:p></p>

<ul style="margin-top: 0in" type="disc">
<li>Software isn't like engineering</li>
<li>Tolerances are much tighter
<ul style="margin-top: 0in" type="circle">
<li>If you get a light-switch cover wrong in a building, the building won't fall down</li>
<li>The same is not true of software</li>
</ul>
</li>
<li>More flexible &ndash; you can test those tolerances in ways you just can't do in the real world
<ul style="margin-top: 0in" type="circle">
<li>Can mathematically prove the strength of a bridge, but you can't really do that with software</li>
<li>Can't do test-first with a bridge, because you lose a lot of trucks</li>
<li>You can throw as many trucks as you want at a piece of software</li>
</ul>
</li>
<li>Instead of telling the developers how to write software, why don't we find out how they work best?
<ul style="margin-top: 0in" type="circle">
<li>Tight time constraints</li>
<li>Business risk of building software is too high</li>
<li>Observe successful and unsuccessful projects, and figure out what they did right/wrong</li>
</ul>
</li>
<li>17 Really Smart Guys met in Snowbird, <st1:state><st1:place>Utah</st1:place></st1:state> in February 2001
<ul style="margin-top: 0in" type="circle">
<li>XP, Scrum, etc. were all around</li>
<li>Expected to spend the whole time arguing</li>
<li>Actually wound up writing the Agile Manifesto</li>
<li><a href="http://agilemanifesto.org/">http://agilemanifesto.org/</a></li>
<li>You cannot create a prescriptive process that says "This is how you write software. Go do this."</li>
</ul>
</li>
</ul>
<p>Principles</p>

<ul style="margin-top: 0in" type="disc">
<li>Our highest priority is to satisfy the customer through early and continuous delivery of valuable software.
<ul style="margin-top: 0in" type="circle">
<li>Delivery of working software &ndash; not design documents</li>
<li>Quick wins, high visibility, customer sees it sooner</li>
<li>Customer sees it sooner, so you know whether you're still on the right track</li>
<li>Emphasis is on delivering most important (not hardest, not easiest) parts first, as defined by the customer</li>
<li>"Most important" will change throughout the course of the project. This is okay.</li>
</ul>
</li>
<li>Deliver working software frequently, from a couple of weeks to a couple of months, with a preference to the shorter timescale.
<ul style="margin-top: 0in" type="circle">
<li>Most projects run 1-3 month cycles, with shorter iterations within that</li>
<li>Anything longer than that, you fall back into the bad zone</li>
<li>The iteration is complete at the end of the iteration, at the expense of moving requirements</li>
<li>IT thinks management doesn't want to hear bad news, so we sugarcoat the news. "I'll be done in a week."</li>
<li>They don't mind bad news as long as there's a good reason. But they hate feeling like they're being lied to. But you're not always lying, because you don't always know how much it's going to take to be finished.</li>
<li>Actual users review actual software during the process</li>
</ul>
</li>
<li>Working software is the primary measure of progress.
<ul style="margin-top: 0in" type="circle">
<li>Does not discard the need for design documentation &ndash; but you diagram to understand, then move to code, and let the diagram wither and die</li>
<li>Whiteboards</li>
<li>"Do Not Erase" must have a date</li>
<li>Draw on a whiteboard, then take a digital photo</li>
</ul>
</li>
<li>Welcome changing requirements, even late in development. Agile processes harness change for the customer's competitive advantage.
<ul style="margin-top: 0in" type="circle">
<li>If you can gracefully accommodate changing requirements and your competition can't, you win.</li>
</ul>
</li>
<li>Business people and developers must work together daily throughout the project.
<ul style="margin-top: 0in" type="circle">
<li>There is a strong correlation between links to users and project success. [Frakes 1995]</li>
<li>When you get to the point of actually writing the code, design questions come up that you couldn't have anticipated. If the customer isn't available, you have to guess, and you probably won't come up with what they want.</li>
<li>The longer it takes to get information to and from the developers, the more damage will occur in the project. The farther you are from the information, the worse the information is.</li>
<li>XP insists that business stakeholders are part of the development team. Full-time.
<ul style="margin-top: 0in" type="square">
<li>This doesn't really fly, because the customer has other work to do</li>
<li>Business analysts can be an effective go-between</li>
</ul>
</li>
</ul>
</li>
<li>Build projects around motivated individuals. Give them the environment and support they need, and trust them to get the job done.
<ul style="margin-top: 0in" type="circle">
<li>"It is better to have motivated, skilled people communicating well and using no process at all than a well-defined process used by unmotivated individuals." [Cockburn 2002]</li>
<li>Avoid interruptions
<ul style="margin-top: 0in" type="square">
<li>Development is both creative and technical</li>
<li>Works best when you get into "flow" mode</li>
<li>If you get broken out of flow, it takes ~15 minutes to get back in</li>
<li>The more interruptions, the harder it is to get back into the flow</li>
<li>If you have a lot of interruptions (meetings, support calls, etc.), try instituting Quiet Time for the programmers. Turn off the phone and e-mail, no meetings, etc.</li>
<li>If a question comes up, go ask the business analyst &ndash; that's OK, it's still on-topic and won't interrupt flow like a random phone call will.</li>
</ul>
</li>
</ul>
</li>
<li>Developers are the Key
<ul style="margin-top: 0in" type="circle">
<li>Hire the smartest people you can find</li>
<li>If you read the wikipedia description of Asperger's Syndrome, you'll swear it's every programmer you've ever met</li>
</ul>
</li>
<li>The most efficient and effective method of conveying information to and within a development team is face-to-face conversation.
<ul style="margin-top: 0in" type="circle">
<li>Written requirements are not rich and not interactive</li>
<li>Two people at a whiteboard are both rich and interactive</li>
</ul>
</li>
<li>"Knowledge radiators" &ndash; inadvertent communication
<ul style="margin-top: 0in" type="circle">
<li>Move stories up as they're completed</li>
<li>Put user stories near a hallway or a coffee machine &ndash; people accidentally find out the status of the whole project</li>
</ul>
</li>
<li>The best architectures, requirements, and designs emerge from self-organizing teams.
<ul style="margin-top: 0in" type="circle">
<li>In small steps over time</li>
<li>All 3 must be allowed to grow and change</li>
<li>No ivory-tower architects that hand something down from on high</li>
<li>"Architecture": Stuff that's hard to change later. Have as little as possible.</li>
<li>Favor chaos over order?</li>
</ul>
</li>
<li>Continuous attention to technical excellence and good design enhances agility.
<ul style="margin-top: 0in" type="circle">
<li>Create good designs initially, then review and improve regularly</li>
<li>Design cleanup as compared to debt [Cunningham 2001]</li>
</ul>
</li>
<li>Agile promotes sustainable development. The sponsors, developers, and users should be able to maintain a constant pace indefinitely.
<ul style="margin-top: 0in" type="circle">
<li>Social aspect
<ul style="margin-top: 0in" type="square">
<li>Alert, engaged staff is more effective than a tired, plodding staff</li>
<li>Long hours are a symptom that something has gone wrong</li>
<li>Only work 8 hours a day</li>
<li>Never put in overtime 2 weeks in a row</li>
</ul>
</li>
<li>Technical aspect
<ul style="margin-top: 0in" type="square">
<li>Development can be viewed as a long strategic game</li>
<li>Each move sets up the next move</li>
</ul>
</li>
</ul>
</li>
<li>Simplicity &ndash; the art of maximizing the amount of work not done &ndash; is essential.
<ul style="margin-top: 0in" type="circle">
<li>"This letter is longer than I wish, for I had not the time to make it shorter." &ndash; Blaise Pascal</li>
<li>Sometimes more difficult to make things simpler</li>
<li>DRY (Don't Repeat Yourself)</li>
<li>"Design for simplicity; add complexity only where you must." Art of Unix Programming, Raymond 2003</li>
<li>"Code smell"</li>
</ul>
</li>
<li>At regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behavior accordingly.
<ul style="margin-top: 0in" type="circle">
<li>Be constantly aware</li>
<li>Never get lazy</li>
<li>XP encourages this: one step is to fix XP when it breaks</li>
<li>How light is too light?</li>
<li>How simple is too simple?</li>
<li>Can we make this simpler?</li>
</ul>
</li>
</ul>
