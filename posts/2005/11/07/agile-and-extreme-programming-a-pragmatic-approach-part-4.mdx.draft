---
title: "Agile and Extreme Programming: A Pragmatic Approach (part 4)  #.NET  #Delphi  #borcon2005  #extreme programming"
sort: 2217
---
<p>Stand-Up Meeting</p>
<ul style="MARGIN-TOP: 0in" type=disc>
<li>Every day starts with a stand-up meeting</li>
<ul style="MARGIN-TOP: 0in" type=circle>
<li>Problems</li>
<li>Solutions</li>
<li>Obstacles</li></ul>
<li>You have to stand up. Otherwise people will get comfortable and it'll take too long.</li>
<li>More efficient to have one short meeting with everyone, than a lot of little meetings</li>
<li>Cross-team communication is the primary purpose</li>
<li>Part of the daily feedback loop</li>
<li>Substitute with something that provides daily updates, problems encountered and solved, etc. (wiki, information radiators) but these aren't as ruch a communications channel</li></ul>
<p>Fix XP when it breaks</p>
<ul style="MARGIN-TOP: 0in" type=disc>
<li>Nothing should be prescriptive &#8211; if something isn't working for you, fix it (making sure you're not losing any feedbackloops)</li></ul>
<p>Build Your Own Tools</p>
<ul style="MARGIN-TOP: 0in" type=disc>
<li>for tracking projects</li>
<li>Evolve your approach over time</li>
<li>Changes from project to project</li>
<li>You get better and better at it</li>
<li>Each PM should create their own tracking sheet &#8211; not take someone else's and mush it around. Psychological &#8211; owning the thing you built.</li>
<li>Project Manager is liaison between programmers and management &#8211; PM's job is to provide facts to management</li></ul>
<p>Designing Practices</p>
<p>Simplicity</p>
<ul style="MARGIN-TOP: 0in" type=disc>
<li>A simple design takes more time than a complex one</li>
<li>When you find something complex, replace it with something simple</li>
<li>No substitute!</li></ul>
<p>System Metaphor</p>
<ul style="MARGIN-TOP: 0in" type=disc>
<li>Keeps team on the same page by naming classes and methods consistently</li>
<li>Stick as close to the problem domain as possible</li>
<li>Take time to do this no matter your methodology</li></ul>
<p>CRC Cards (Class, Responsibility, and Collaboration)</p>
<ul style="MARGIN-TOP: 0in" type=disc>
<li>Use for design sessions</li>
<li>Break away from procedural thought, more fully appreciate OO</li>
<li>Individual CRC cards represent objects</li>
<li>Write class name at the top, responsibilities (what it's responsible for) along the left, collaborations along the right</li>
<li>Shuffle them around on the table to find relationships you like</li>
<li>Prefer hand-written on paper, instead of something created in Visio (this also applies to UI brainstorming)</li>
<li>Step through workflow, spot weaknesses and problems</li>
<li>Easy to change, but pick something flexible, interactive, whole-team, serves stakeholders, allows "What If" games</li>
<li>Many companies prefer more documentation than CRC cards provide</li>
<ul style="MARGIN-TOP: 0in" type=circle>
<li>"We have to have documentation so that&#8230;" Make manager finish this sentence</li>
<li>&#8230;we can re-create the whole project?</li>
<li>&#8230;we can kill more trees?</li>
<li>&#8230;we know what it does?</li>
<li>The tests are better documentation than any outdated Word document</li>
<li>You can verify, at any time, that the code is doing what it's supposed to &#8211; just run the tests</li></ul>
<li>If you must write documentation for the code, apply DRY (Don't Repeat Yourself). There should be one canonical source of truth for each piece of information &#8211; if you need it somewhere else, find a way to generate it.</li>
<ul style="MARGIN-TOP: 0in" type=circle>
<li>yDoc &#8211; tool that creates UML diagrams by looking at the actual code (!)</li>
<li>If you really need to manually create developer documentation, make a story card for it in the iteration, so management can see how much more you could be doing if it wasn't required</li></ul></ul>
<p>Spikes</p>
<ul style="MARGIN-TOP: 0in" type=disc>
<li>Proof of concept</li>
<li>Not called "prototypes" because people try to keep prototypes and turn them into the actual project. Never do this &#8211; always throw spikes away.</li></ul>
<p>YAGNI</p>
<ul style="MARGIN-TOP: 0in" type=disc>
<li>No functionality is added early</li>
<li>Don't substitute this!</li></ul>
<p>Refactor</p>
<ul style="MARGIN-TOP: 0in" type=disc>
<li>whenever and wherever possible</li>
<li>You must be willing to change code any time it should be changed</li>
<li>Don't live with broken windows</li>
<ul style="MARGIN-TOP: 0in" type=circle>
<li>Nobody will bother the abandoned warehouse until the first window gets broken&#8230; then all the windows get broken, graffiti, etc.</li>
<li>The first broken window means "I don't care."</li>
<li>Read "The Pragmatic Programmer"</li></ul>
<li>Too much software becomes brittle because of hundreds of tiny compromises</li></ul>
<p>Coding Practices</p>
<p>Customer is always available</p>
<ul style="MARGIN-TOP: 0in" type=disc>
<li>Business stakeholder must be available</li>
<li>If you can't get a business person, get a worthy substitute</li>
<li>Tell them: requirements docs are out of date as soon as they're written</li>
<li>Programmers aren't business people</li></ul>
<p>Coding Standards</p>
<p><?xml:namespace prefix = o ns = "urn:schemas-microsoft-com:office:office" /><o:p>&nbsp;</o:p></p>
<p>Test-First Coding</p>
<ul style="MARGIN-TOP: 0in" type=disc>
<li>Least done, most important</li>
<li>First write the test, then make it pass</li>
<li>Helps developer to really consider what needs to be done</li>
<li>Requirements are nailed down firmly by tests</li>
<li>Can't misunderstand a spec written in executable code</li>
<li>The most effective way to write code. You get feedback right away.</li>
<li>You get nearly as good feedback if you write tests concurrently. (But do it &#8211; planning to write them next week doesn't count!)</li>
<li>Tests are the only way you can write code with confidence</li>
<li>Tell management: "This *is* the set of requirements"; "Here's the coverage test that tells how much of our code is verified."</li></ul>
<p>Pair Programming</p>
<ul style="MARGIN-TOP: 0in" type=disc>
<li>The most Extreme practice in XP!</li>
<li>Two people working at the same computer will add about as much functionality as 2 people working separately &#8211; but it will be much higher quality</li>
<ul style="MARGIN-TOP: 0in" type=circle>
<li>Person at keyboard thinks about low-level details</li>
<li>Pair thinks about larger context</li></ul>
<li>Increases software quality without impacting time to deliver</li>
<li>Works best with 2 developers of more or less equal skill</li>
<li>Truck number again</li>
<li>Pair programming feels awkward at first</li>
<li>ThoughtWorks has two monitors, two mice, and two keyboards at each station</li>
<li>Tough to substitute because it's the most immediate code feedback loop (on the order of minutes)</li>
<li>Try sneaking it in on the hard problems. Then show quantifiable results (bug counts, passed tests).</li>
<li>Treat it as real-time code review.</li></ul>
<p>Integration</p>
<p><o:p>&nbsp;</o:p></p>
<p>Collective Code Ownership</p>
<ul style="MARGIN-TOP: 0in" type=disc>
<li>Hard!</li>
<li>Try to adopt this whatever your methodology</li></ul>
<p>Leave optimization to last</p>
<p><o:p>&nbsp;</o:p></p>
<p>No overtime</p>
<ul style="MARGIN-TOP: 0in" type=disc>
<li>Sucks the spirit and motivation out of the team</li>
<li>Write worse code when you're worn out</li></ul>
<p>Tests</p>
<ul style="MARGIN-TOP: 0in" type=disc>
<li>Unit tests</li>
<li>Acceptance tests for everything, because that's the only way you know when the story is done</li></ul>
<p>Demonstrate that XP works! Pilot projects, metrics, etc.</p>
<p><o:p>&nbsp;</o:p></p>
<p>Substitution Scale: table summarizing what's easy to substitute and what's hard (will post this later today)</p>
