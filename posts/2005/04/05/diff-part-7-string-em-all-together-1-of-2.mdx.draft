---
title: "Diff, part 7: String 'em all together? (1 of 2)  #.NET  #Delphi  #diff"
sort: 2140
---
Continuing the <a href="http://blog.excastle.com/tag/diff/">Diff for the Complete Goober</a> series (after a brief hiatus on account of <a href="http://blog.excastle.com/2005/04/04/sleep-losing-time/">Deleted Sleep Time</a>):

The core problem of diff is the building of the <a href="http://blog.excastle.com/2005/03/29/diff-part-3-introducing-the-longest-common-subsequence/">longest common subsequence</a>, which we accomplish by finding all the <a href="http://blog.excastle.com/2005/03/31/diff-part-4-matches/">matches</a> in the two lists, then assembling <a href="http://blog.excastle.com/2005/04/01/diff-part-5-match-strings/">match strings</a> that match our <a href="http://blog.excastle.com/2005/04/02/diff-part-6-match-strings-and-common-subsequences/">rule</a> (which filters out the match strings that are not <a href="http://blog.excastle.com/2005/03/29/diff-part-3-introducing-the-longest-common-subsequence/">common subsequences</a>).

Does it have to be that complicated? Let's just try it. Say we have these two lists:
<blockquote dir="ltr" style="margin-right: 0px"><font face="Courier New">A is (1 2 3 4)
B is (1 3 4)
</font>Matches: <font face="Courier New">[0,0]</font>, <font face="Courier New">[2,1]</font>, and <font face="Courier New">[3,2]</font>.</blockquote>

<p dir="ltr">Do we really need to go through all the rigamarole? You can build a match string out of all three matches in their original order, and it'll be a common subsequence â€” and at length 3, it'll be the longest common subsequence. So our LCS has to be <font face="Courier New">[0,0] [2,1] [3,2]</font>.</p>
<p dir="ltr">Well, that was easy. Grab all the matches, put them together, and there's the LCS. It can't be that easy, can it? Well... no, actually, it can't:</p>

<blockquote dir="ltr" style="margin-right: 0px">
<p dir="ltr"><font face="Courier New">A is (1 2 3)
B is (1 3 2)
</font>Matches: <font face="Courier New">[0,0]</font>, <font face="Courier New">[1,2]</font>, and <font face="Courier New">[2,1]</font>.</blockquote>



<p dir="ltr">If we try stringing these all together, we get <font face="Courier New">[0,0] [1,2] [2,1]</font>, which isn't a valid common subsequence. In this case, the real LCS is going to be length 2: either <font face="Courier New">[0,0] [1,2]</font> or <font face="Courier New">[0,0] [2,1]</font>; take your pick.</p>
<p dir="ltr">Can we adapt our simple "string 'em all together" strategy to work with these inputs? Well, we could start with <font face="Courier New">[0,0]</font>, and keep adding matches on, as long as the result is still a valid CS; and just throw away any matches that we can't append to our longest-running-common-subsequence. Let's try that.</p>

<ul dir="ltr">
	<li>First match: <font face="Courier New">[0,0]</font>. This gives us a length-1 match string that is a valid CS. (Actually, any length-1 match string will always be a valid CS.)</li>
	<li>Next match: <font face="Courier New">[1,2]</font>. Add that to our best CS so far. Result: <font face="Courier New">[0,0] [1,2]</font>. This is a valid CS; keep it.</li>
	<li>Next match: <font face="Courier New">[2,1]</font>. Add that to our best CS so far. Result: <font face="Courier New">[0,0] [1,2] [2,1]</font>. This is not a valid CS; throw it out. Our best CS so far is still <font face="Courier New">[0,0] [1,2]</font>.</li>
</ul>
That looks promising, doesn't it? Let's try it with a slightly different input:
<blockquote dir="ltr" style="margin-right: 0px">
<p dir="ltr"><font face="Courier New">A is (1 2 3 4)
B is (1 3 2 4)
</font>Matches: <font face="Courier New">[0,0]</font>, <font face="Courier New">[1,2]</font>, <font face="Courier New">[2,1]</font><font face="Times New Roman">, and <font face="Courier New">[3,3]</font>.</font></blockquote>
<p dir="ltr">The lists are the same as above, but with one more match. So we do the same thing as above, but with one more step at the end:</p>

<ul dir="ltr">
	<li>Next match: <font face="Courier New">[3,3]</font>. Add that to our best CS so far. Result: <font face="Courier New">[0,0] [1,2] [3,3]</font>. This is a valid CS; keep it.</li>
</ul>
Again, we get the right LCS. Looking good! One more example:
<blockquote dir="ltr" style="margin-right: 0px">
<p dir="ltr"><font face="Courier New">A is (1 2 3 4 5)
B is (5 2 3 4 1)
</font>Matches: <font face="Courier New">[0,4]</font>, <font face="Courier New">[1,1]</font>, <font face="Courier New">[2,2]<font face="Times New Roman">, </font><font face="Courier New">[3,3]</font></font>, and <font face="Times New Roman"><font face="Courier New">[4,0]</font>.</font></blockquote>
<p dir="ltr">Steps:</p>

<ul dir="ltr">
	<li>First match: <font face="Courier New">[0,4]</font>. This gives us a length-1 match string that is a valid CS.</li>
	<li>Next match: <font face="Courier New">[1,1]</font>. Add that to our best CS so far. Result: <font face="Courier New">[0,4] [1,1]</font>. This is not a valid CS; throw it out. Our best CS so far is still <font face="Courier New">[0,4]</font>.</li>
	<li>Next match: <font face="Courier New">[2,2]</font>. Add that to our best CS so far. Result: <font face="Courier New">[0,4] [2,2]</font>. This is not a valid CS; throw it out. Our best CS so far is still <font face="Courier New">[0,4]</font>.</li>
	<li>Next match: <font face="Courier New">[3,3]</font>. Add that to our best CS so far. Result: <font face="Courier New">[0,4] [3,3]</font>. This is not a valid CS; throw it out. Our best CS so far is still <font face="Courier New">[0,4]</font>.</li>
	<li>Next match: <font face="Courier New">[4,0]</font>. Add that to our best CS so far. Result: <font face="Courier New">[0,4] [4,0]</font>. This is not a valid CS; throw it out. Our best CS so far is still <font face="Courier New">[0,4]</font>.</li>
</ul>
So our modified "string 'em all together" algorithm gives us an LCS of [0,4]. But wait â€” that's not right. There are three matches right in a row, in the middle of the inputs. The LCS should be [1,1] [2,2] [3,3]. What does that mean?

Well, it means that our algorithm isn't right yet. Next time, I'll add a refinement that would make it work for all these inputs.

(Notice, though, that I said <em>these</em> inputs. I've still got several more articles to go.)
