---
title: "Diff, part 14: Expendability  #.NET  #Delphi  #diff"
sort: 2150
---
Last time, on the <a href="http://blog.excastle.com/tag/diff/">Diff Chronicles</a>, I brought up a useful optimization called <a href="http://blog.excastle.com/2005/04/13/diff-part-13-maxlength-and-driving-directions/">MaxLength</a>. But useful as it is, it's totally impractical to put into practice, because finding the exact MaxLength takes too long.

But what if we could look at two CSes, and know that one's MaxLength is better than the other's, <em>without actually calculating their MaxLengths?</em>

Let's define a new function, called Expendable(CS<sub><small>1</small></sub>, CS<sub><small>2</small></sub>). We give it two CSes, and it tells us which of them we can throw away. Sometimes it returns nil, meaning we can't throw either of them away. (Thanks to <a href="http://www.alieniloquent.com/">Sam</a> for suggesting that this be a function â€” it simplifies the explanation quite a bit.)



Assuming that we can implement the Expendable function, it's simple to plug it into <a href="http://blog.excastle.com/2005/04/13/diff-part-13-maxlength-and-driving-directions/">yesterday's algorithm</a>: Every time we come up with a new CS that we want to add to our list, we first loop through our existing CSes, and compare each one to our CS<sub><small>new</small></sub>. If Expendable(CS<sub><small><em>i</em></small></sub>, CS<sub><small>new</small></sub>) ever returns CS<sub><small><em>i</em></small></sub>, we delete CS<sub><small><em>i</em></small></sub> from our list, and then move on to CS<sub><small><em>i</em>+1</small></sub>. If Expendable(CS<sub><small><em>i</em></small></sub>, CS<sub><small>new</small></sub>) ever returns CS<sub><small>new</small></sub>, we stop there, and don't bother adding CS<sub><small>new</small></sub> to our list. And whenever Expendable(CS<sub><small><em>i</em></small></sub>, CS<sub><small>new</small></sub>) returns nil, we just keep going.

This is essentially what we did yesterday, but we were using an Expendable function that was implemented in terms of MaxLength. Now we just have to figure out how to implement the Expendable function <em>without</em> using that expensive MaxLength calculation. How do we look at two CSes and figure out that we can eliminate one without hurting our chances of finding the LCS?

Let's look at (you knew this was coming, didn't you?) some examples:

<ul>
<li>Expendable(<font face="Courier New">[0,0] [1,1]</font>, <font face="Courier New">[1,1]</font>) =&gt; <font face="Courier New">[1,1]</font>.
Anything we can add onto one of these, we can add onto the other. But one of them is already longer. It's a sure thing that MaxLength(<font face="Courier New">[0,0] [1,1]</font>) = MaxLength(<font face="Courier New">[1,1]</font>) + 1; we can tell that without knowing exactly what their MaxLengths are. Therefore, <font face="Courier New">[0,0] [1,1]</font> wins, and <font face="Courier New">[1,1]</font> gets flushed.</li>
<li>Expendable(<font face="Courier New">[0,0]</font>, <font face="Courier New">[1,1]</font>) =&gt; <font face="Courier New">[1,1]</font>.
We know that there's a match <font face="Courier New">[1,1]</font> out there somewhere, because it's in the second CS. So we know that the <font face="Courier New">[0,0]</font> will end up growing to <font face="Courier New">[0,0] [1,1]</font> sooner or later. That means that this example is exactly the same thing as the previous example, and we already know that once it grows to that point, <font face="Courier New">[1,1]</font> is going to lose. Why wait that long? We can just cut our losses now, and toss the second CS right away.</li>
<li>Expendable(<font face="Courier New">[3,6]</font>, <font face="Courier New">[5,2]</font>) =&gt; nil.
We can't eliminate <font face="Courier New">[3,6]</font> because it might well be part of the LCS. For example, there might be only one more match after this, and that match might be <font face="Courier New">[4,7]</font>. We can't eliminate <font face="Courier New">[5,2]</font> because there might be only one more match, and it might be <font face="Courier New">[6,3]</font>. We can't guarantee that either of these CSes is out of the running, so we can't eliminate either one.</li>
<li>Expendable(<font face="Courier New">[0,5] [1,6] [2,7]</font>, <font face="Courier New">[3,0]</font>) =&gt; nil.
It's tempting to say, "We're working towards the longest possible CS, so when we need to throw one away, go for the shorter one." But we've <a href="http://blog.excastle.com/2005/04/05/diff-part-7-string-em-all-together-1-of-2/">tried that before</a>, and it didn't work. If the next three matches are <font face="Courier New">[4,1]</font>, <font face="Courier New">[5,2]</font>, and <font face="Courier New">[6,3]</font>, then <font face="Courier New">[3,0]</font> will grow into the next big powerhouse, because we can add those matches onto <font face="Courier New">[3,0]</font> to get a length-4 CS, but we can't add them onto <font face="Courier New">[0,5] [1,6] [2,7]</font>. Bottom line, we can't throw away either CS without waiting to see what other matches are yet to come.</li>
<li>Expendable(<font face="Courier New">[4,0]</font>, <font face="Courier New">[4,4]</font>) =&gt; <font face="Courier New">[4,4]</font>.
We can guarantee that throwing away <font face="Courier New">[4,4]</font> won't hurt our chances of finding the right LCS. There is no possible way that MaxLength(<font face="Courier New">[4,4]</font>) could be larger than MaxLength(<font face="Courier New">[4,0]</font>), but there are possible ways that MaxLength(<font face="Courier New">[4,0]</font>) could be better; for example, the next match might be <font face="Courier New">[5,2]</font>, which would grow <font face="Courier New">[4,0]</font> but would not grow <font face="Courier New">[4,4]</font>. It's not guaranteed that <font face="Courier New">[4,0]</font> <em>will</em> result in a better MaxLength, but it is guaranteed that it won't ever be worse.</li>
</ul>

<p dir="ltr">The basic concept is something I think of as "growth potential". <font face="Courier New">[0,0]</font> has more room to grow than <font face="Courier New">[1,1]</font> does; <font face="Courier New">[1,1]</font> is already closer to the end of the lists, and you can't build your Lego tower much higher if there's a ceiling in the way. <font face="Courier New">[4,0]</font> has more room to grow than <font face="Courier New">[4,4]</font> does. But whether <font face="Courier New">[3,6]</font> has more room to grow than <font face="Courier New">[5,2]</font> depends on a lot of things, like the size of the input lists, and where the matches fall; so neither one is guaranteed expendable.</p>
<p dir="ltr">Tomorrow, I'll provide an actual algorithm for the Expendable function, and put it to work.</p>
